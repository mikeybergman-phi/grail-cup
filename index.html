<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>φ Spiral Bowl — Minimal Rainbow Spin (Auto-play)</title>
<style>
  html,body{height:100%;margin:0;background:#0b0e13;color:#e7eaee;font:14px ui-sans-serif,system-ui,-apple-system}
  #app{position:fixed;inset:0}
  .ui{position:fixed;top:12px;left:12px;background:rgba(15,22,32,.92);border:1px solid #233244;border-radius:12px;
      padding:12px;display:grid;gap:10px;min-width:520px}
  .row{display:flex;align-items:center;gap:10px}
  .row label{flex:1;color:#9fb1c7}
  .row input[type="range"]{flex:2}
  .row output{min-width:68px;text-align:right;color:#ffd66b}
  button{background:#0f1725;border:1px solid #2c4461;color:#e7eaee;padding:6px 10px;border-radius:8px;cursor:pointer}
  button:hover{border-color:#446c96}
  .small{color:#9fb1c7;font-size:12px;line-height:1.35}
</style>
</head>
<body>
<div id="app"></div>

<div class="ui">
  <div class="small">
    360 copies of a <b>3D φ-log spiral</b> (tube radius <b>0.003</b>) on a <b>63.435°</b> cone (axis +Z), rotated in 1° steps about the <b>world X-axis</b>.<br>
    The <b>color gradient runs rim→apex</b> and shifts through the rainbow as it spins.
  </div>

  <div class="row"><label>Rim radius (a)</label><input id="a" type="range" min="0.20" max="3.00" step="0.01" value="1.40"><output id="aOut">1.40</output></div>
  <div class="row"><label>Inward turns</label><input id="turns" type="range" min="0.5" max="16" step="0.5" value="7.0"><output id="turnsOut">7.0</output></div>
  <div class="row"><label>Curve segments</label><input id="segs" type="range" min="300" max="6000" step="50" value="2000"><output id="segsOut">2000</output></div>

  <div class="row"><label>Speed (°/s)</label><input id="speed" type="range" min="0" max="360" step="1" value="60"><output id="speedOut">60</output></div>
  <div class="row">
    <button id="playPause">▶ Play</button>
    <button id="oneRev">One revolution</button>
    <label style="display:flex;align-items:center;gap:8px; margin-left:auto;">
      <input id="autoplay" type="checkbox" checked> Auto-play
    </label>
  </div>

  <div class="row">
    <button id="resetView">Reset view</button>
    <button id="lookZ">Look +Z</button>
    <button id="lookX">Look +X</button>
  </div>
</div>

<!-- Import map -->
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";

const PHI=(1+Math.sqrt(5))/2;
const K=2*Math.log(PHI)/Math.PI;
const APEX_DEG=63.435;
const HALF_ANG=(APEX_DEG*Math.PI/180)/2;
const m=Math.tan(HALF_ANG);
const TWO_PI=Math.PI*2;

const $=id=>document.getElementById(id);
const ui={
  a:$('a'), turns:$('turns'), segs:$('segs'), speed:$('speed'),
  playPause:$('playPause'), oneRev:$('oneRev'), autoplay:$('autoplay'),
  resetView:$('resetView'), lookZ:$('lookZ'), lookX:$('lookX'),
  aOut:$('aOut'), turnsOut:$('turnsOut'), segsOut:$('segsOut'), speedOut:$('speedOut')
};
function syncOut(){
  ui.aOut.textContent=(+ui.a.value).toFixed(2);
  ui.turnsOut.textContent=(+ui.turns.value).toFixed(1);
  ui.segsOut.textContent=(+ui.segs.value);
  ui.speedOut.textContent=(+ui.speed.value);
}

/* Scene */
const scene=new THREE.Scene();
scene.background=new THREE.Color(0x0b0e13);
const camera=new THREE.PerspectiveCamera(56, innerWidth/innerHeight, 0.01, 2000);
camera.position.set(4.0,3.2,4.2);

const app=document.getElementById('app');
const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.setSize(innerWidth,innerHeight);
app.appendChild(renderer.domElement);

const controls=new OrbitControls(camera, renderer.domElement);
controls.enableDamping=true;

scene.add(new THREE.HemisphereLight(0xffffff,0x0a0f15,0.9));
const key=new THREE.DirectionalLight(0xffffff,0.9); key.position.set(3,5,4); scene.add(key);
const fill=new THREE.AmbientLight(0xffffff,0.35); scene.add(fill);

const world=new THREE.Group(); scene.add(world);
const spinner=new THREE.Group(); world.add(spinner);

class ConeLogSpiralZ extends THREE.Curve{
  constructor({a,thetaMax,handed=+1}){ super(); this.a=a; this.thetaMax=thetaMax; this.handed=Math.sign(handed)||+1; }
  getPoint(t){
    const th=t*this.thetaMax, r=this.a*Math.exp(-K*th), ang=this.handed*th;
    return new THREE.Vector3(r*Math.cos(ang), r*Math.sin(ang), r/m);
  }
}

const tubeRadius=0.003, steps=360;
let tubularSegments=2000, radialSegments=20, inst=null;

function setLengthwiseRainbow(geom, phase01){
  const loops=tubularSegments+1, ring=radialSegments+1;
  const colors=new Float32Array(geom.attributes.position.count*3);
  const col=new THREE.Color();
  for(let i=0;i<geom.attributes.position.count;i++){
    const loopIdx=Math.floor(i/ring);
    const t=loopIdx/tubularSegments;
    const hue=(t+phase01)%1.0;
    col.setHSL(hue,1.0,0.5);
    const o=i*3;
    colors[o]=col.r; colors[o+1]=col.g; colors[o+2]=col.b;
  }
  geom.setAttribute('color', new THREE.Float32BufferAttribute(colors,3));
}

function build(){
  if(inst){ spinner.remove(inst); inst.geometry.dispose(); inst.material.dispose(); inst=null; }

  const a=+ui.a.value;
  const turns=+ui.turns.value;
  tubularSegments=Math.max(300, Math.floor(+ui.segs.value));
  const thetaMax=turns*TWO_PI;

  const curve=new ConeLogSpiralZ({a,thetaMax,handed:+1});
  const tube=new THREE.TubeGeometry(curve,tubularSegments,tubeRadius,radialSegments,false);

  setLengthwiseRainbow(tube,0);
  const mat=new THREE.MeshStandardMaterial({vertexColors:true,metalness:0.15,roughness:0.35});

  inst=new THREE.InstancedMesh(tube,mat,steps);
  const M=new THREE.Matrix4();
  for(let i=0;i<steps;i++){
    const ang=(i*Math.PI)/180;
    M.makeRotationX(ang);
    inst.setMatrixAt(i,M);
  }
  inst.frustumCulled=false;
  spinner.add(inst);

  syncOut();
}

function resetView(){ camera.position.set(4.0,3.2,4.2); controls.target.set(0,0.8,0.8); controls.update(); }
function lookZ(){ camera.position.set(0,0,6.4); controls.target.set(0,0,0.9); controls.update(); }
function lookX(){ camera.position.set(6.4,0,0.9); controls.target.set(0,0,0.9); controls.update(); }

['a','turns','segs'].forEach(id=>$(id).addEventListener('input', build));
ui.speed.addEventListener('input', syncOut);

let isPlaying=false, remaining=0;
ui.playPause.addEventListener('click',()=>{
  isPlaying=!isPlaying;
  ui.playPause.textContent=isPlaying?'⏸ Pause':'▶ Play';
});
ui.oneRev.addEventListener('click',()=>{
  remaining=TWO_PI; isPlaying=true;
  ui.playPause.textContent='⏸ Pause';
});
ui.autoplay.addEventListener('change',()=>{
  // If toggled on, start spinning immediately; if off, pause.
  isPlaying = ui.autoplay.checked;
  ui.playPause.textContent=isPlaying?'⏸ Pause':'▶ Play';
});

ui.resetView.addEventListener('click', resetView);
ui.lookZ.addEventListener('click', lookZ);
ui.lookX.addEventListener('click', lookX);

build(); resetView();

// Auto-play on load if checked
if(ui.autoplay.checked){
  isPlaying = true;
  ui.playPause.textContent='⏸ Pause';
}

const clock=new THREE.Clock();
let rotAccum=0;
function tick(){
  const dt=clock.getDelta(), ω=(+ui.speed.value)*Math.PI/180;
  if(isPlaying&&ω>0&&inst){
    let dθ=ω*dt;
    if(remaining>0){
      if(dθ>=remaining){ dθ=remaining; isPlaying=false; remaining=0; ui.playPause.textContent='▶ Play'; }
      else remaining-=dθ;
    }
    const q=new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0),dθ);
    spinner.quaternion.premultiply(q);
    rotAccum=(rotAccum+dθ)%TWO_PI;
    const phase=rotAccum/TWO_PI;
    setLengthwiseRainbow(inst.geometry,phase);
    inst.geometry.attributes.color.needsUpdate=true;
  }
  controls.update();
  renderer.render(scene,camera);
  requestAnimationFrame(tick);
}
tick();

addEventListener('resize',()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>


