<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>φ Spiral Bowl — Minimal Rainbow Spin (with White Reference)</title>
<style>
  html,body{height:100%;margin:0;background:#0b0e13;color:#e7eaee;font:14px ui-sans-serif,system-ui,-apple-system}
  #app{position:fixed;inset:0}
  .ui{position:fixed;top:12px;left:12px;background:rgba(15,22,32,.92);border:1px solid #233244;border-radius:12px;
      padding:12px;display:grid;gap:10px;min-width:460px}
  .row{display:flex;align-items:center;gap:10px}
  .row label{flex:1;color:#9fb1c7}
  .row input[type="range"]{flex:2}
  .row output{min-width:68px;text-align:right;color:#ffd66b}
  button{background:#0f1725;border:1px solid #2c4461;color:#e7eaee;padding:6px 10px;border-radius:8px;cursor:pointer}
  button:hover{border-color:#446c96}
  .small{color:#9fb1c7;font-size:12px;line-height:1.35}
</style>
</head>
<body>
<div id="app"></div>

<div class="ui">
  <div class="small">
    360 copies of a <b>3D φ-log spiral</b> (tube radius <b>0.003</b>) on a <b>63.435°</b> cone (axis +Z), rotated in 1° steps about the <b>world X-axis</b>.<br>
    One spiral (0°) is <b>white</b> for reference; the other 359 use a rim→apex rainbow that shifts as it spins.
  </div>

  <div class="row"><label>Rim radius (a)</label><input id="a" type="range" min="0.20" max="3.00" step="0.01" value="1.40"><output id="aOut">1.40</output></div>
  <div class="row"><label>Inward turns</label><input id="turns" type="range" min="0.5" max="16" step="0.5" value="7.0"><output id="turnsOut">7.0</output></div>
  <div class="row"><label>Curve segments</label><input id="segs" type="range" min="300" max="6000" step="50" value="2000"><output id="segsOut">2000</output></div>

  <div class="row"><label>Speed (°/s)</label><input id="speed" type="range" min="0" max="360" step="1" value="60"><output id="speedOut">60</output></div>
  <div class="row">
    <button id="playPause">▶ Play</button>
    <button id="oneRev">One revolution</button>
    <button id="resetView">Reset view</button>
    <button id="lookZ">Look +Z</button>
    <button id="lookX">Look +X</button>
  </div>
</div>

<!-- Import map -->
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";

const PHI=(1+Math.sqrt(5))/2;
const K=2*Math.log(PHI)/Math.PI;
const APEX_DEG=63.435;
const HALF_ANG=(APEX_DEG*Math.PI/180)/2;
const m=Math.tan(HALF_ANG);
const TWO_PI=Math.PI*2;

const $=id=>document.getElementById(id);
const ui={
  a:$('a'), turns:$('turns'), segs:$('segs'), speed:$('speed'),
  playPause:$('playPause'), oneRev:$('oneRev'),
  resetView:$('resetView'), lookZ:$('lookZ'), lookX:$('lookX'),
  aOut:$('aOut'), turnsOut:$('turnsOut'), segsOut:$('segsOut'), speedOut:$('speedOut')
};
function syncOut(){
  ui.aOut.textContent=(+ui.a.value).toFixed(2);
  ui.turnsOut.textContent=(+ui.turns.value).toFixed(1);
  ui.segsOut.textContent=(+ui.segs.value);
  ui.speedOut.textContent=(+ui.speed.value);
}

/* Scene */
const scene=new THREE.Scene();
scene.background=new THREE.Color(0x0b0e13);
const camera=new THREE.PerspectiveCamera(56, innerWidth/innerHeight, 0.01, 2000);
camera.position.set(4.0,3.2,4.2);

const app=document.getElementById('app');
const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.setSize(innerWidth,innerHeight);
app.appendChild(renderer.domElement);

const controls=new OrbitControls(camera, renderer.domElement);
controls.enableDamping=true;

scene.add(new THREE.HemisphereLight(0xffffff,0x0a0f15,0.9));
const key=new THREE.DirectionalLight(0xffffff,0.9); key.position.set(3,5,4); scene.add(key);
const fill=new THREE.AmbientLight(0xffffff,0.35); scene.add(fill);

const world=new THREE.Group(); scene.add(world);
const spinner=new THREE.Group(); world.add(spinner);

class ConeLogSpiralZ extends THREE.Curve{
  constructor({a,thetaMax,handed=+1}){ super(); this.a=a; this.thetaMax=thetaMax; this.handed=Math.sign(handed)||+1; }
  getPoint(t){
    const th=t*this.thetaMax, r=this.a*Math.exp(-K*th), ang=this.handed*th;
    return new THREE.Vector3(r*Math.cos(ang), r*Math.sin(ang), r/m);
  }
}

const tubeRadius=0.003;
const stepsTotal=360;           // total copies desired
const rainbowSteps=stepsTotal-1;// leave one for the white ref
let tubularSegments=2000, radialSegments=20, inst=null, whiteRef=null;

function setLengthwiseRainbow(geom, phase01){
  const loops=tubularSegments+1, ring=radialSegments+1;
  const colors=new Float32Array(geom.attributes.position.count*3);
  const col=new THREE.Color();
  for(let i=0;i<geom.attributes.position.count;i++){
    const loopIdx=Math.floor(i/ring);
    const t=loopIdx/tubularSegments;          // 0..1 along length
    const hue=(t+phase01)%1.0;
    col.setHSL(hue,1.0,0.5);
    const o=i*3;
    colors[o]=col.r; colors[o+1]=col.g; colors[o+2]=col.b;
  }
  geom.setAttribute('color', new THREE.Float32BufferAttribute(colors,3));
}

function build(){
  // clear previous
  if(inst){ spinner.remove(inst); inst.geometry.dispose(); inst.material.dispose(); inst=null; }
  if(whiteRef){ spinner.remove(whiteRef); whiteRef.geometry.dispose(); whiteRef.material.dispose(); whiteRef=null; }

  const a=+ui.a.value;
  const turns=+ui.turns.value;
  tubularSegments=Math.max(300, Math.floor(+ui.segs.value));
  const thetaMax=turns*TWO_PI;

  // Base spiral geometry
  const curve=new ConeLogSpiralZ({a,thetaMax,handed:+1});
  const tube=new THREE.TubeGeometry(curve,tubularSegments,tubeRadius,radialSegments,false);

  // White reference spiral at 0°
  whiteRef = new THREE.Mesh(
    tube.clone(),
    new THREE.MeshStandardMaterial({ color:0xffffff, metalness:0.05, roughness:0.3 })
  );
  spinner.add(whiteRef);

  // Rainbow instanced copies for 1..359°
  const rainbowGeo = tube.clone();
  setLengthwiseRainbow(rainbowGeo, 0);
  const rainbowMat = new THREE.MeshStandardMaterial({ vertexColors:true, metalness:0.15, roughness:0.35 });

  inst=new THREE.InstancedMesh(rainbowGeo, rainbowMat, rainbowSteps);
  const M=new THREE.Matrix4();
  for(let i=0;i<rainbowSteps;i++){
    const deg=i+1;                  // 1..359
    const ang=(deg*Math.PI)/180;
    M.makeRotationX(ang);
    inst.setMatrixAt(i,M);
  }
  inst.frustumCulled=false;
  spinner.add(inst);

  syncOut();
}

function resetView(){ camera.position.set(4.0,3.2,4.2); controls.target.set(0,0.8,0.8); controls.update(); }
function lookZ(){ camera.position.set(0,0,6.4); controls.target.set(0,0,0.9); controls.update(); }
function lookX(){ camera.position.set(6.4,0,0.9); controls.target.set(0,0,0.9); controls.update(); }

['a','turns','segs'].forEach(id=>$(id).addEventListener('input', build));
ui.speed.addEventListener('input', syncOut);

let isPlaying=false, remaining=0;
ui.playPause.addEventListener('click',()=>{ isPlaying=!isPlaying; ui.playPause.textContent=isPlaying?'⏸ Pause':'▶ Play'; });
ui.oneRev.addEventListener('click',()=>{ remaining=TWO_PI; isPlaying=true; ui.playPause.textContent='⏸ Pause'; });

ui.resetView.addEventListener('click', resetView);
ui.lookZ.addEventListener('click', lookZ);
ui.lookX.addEventListener('click', lookX);

build(); resetView();

const clock=new THREE.Clock();
let rotAccum=0;
function tick(){
  const dt=clock.getDelta(), ω=(+ui.speed.value)*Math.PI/180;
  if(isPlaying&&ω>0&&inst){
    let dθ=ω*dt;
    if(remaining>0){ if(dθ>=remaining){ dθ=remaining; isPlaying=false; remaining=0; ui.playPause.textContent='▶ Play'; } else remaining-=dθ; }
    const q=new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0),dθ);
    spinner.quaternion.premultiply(q);
    rotAccum=(rotAccum+dθ)%TWO_PI;
    const phase=rotAccum/TWO_PI;
    setLengthwiseRainbow(inst.geometry,phase);
    inst.geometry.attributes.color.needsUpdate=true;
  }
  controls.update();
  renderer.render(scene,camera);
  requestAnimationFrame(tick);
}
tick();

addEventListener('resize',()=>{camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();renderer.setSize(innerWidth,innerHeight);});
</script>
</body>
</html>
